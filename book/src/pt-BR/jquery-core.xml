<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Core (Núcleo) do jQuery</title>

  <section>
    <title><code>$</code> vs <code>$()</code></title>

	<para>Até agora, estivemos lidando inteiramente com métodos que são chamados
    em um objeto jQuery. Por examplo:</para>

    <programlisting>$('h1').remove();</programlisting>

    <para>A maioria dos métodos jQuery é chamada em objetos jQuery como mostrado acima;
    esses métodos são considerados parte do namespace <code>$.fn</code>, ou
    o “protótipo do jQuery”, e são melhor imaginados como métodos do objeto
    jQuery.</para>

    <para>No entanto, há vários métodos que não atuam em uma seleção;
    esses métodos são considerados parte do namespace jQuery, e são melhor
    imaginados como métodos do núcleo do jQuery.</para>

    <para>Esta distinção pode ser incrivelmente confusa para os novos usuários do jQuery.
    Aqui está o que você precisa se lembrar:</para>

    <itemizedlist>
      <listitem>
        <para>Métodos chamados em seleções do jQuery estão no namespace
        <code>$.fn</code>, e automaticamente recebem e retornam a seleção
        como está.</para>
      </listitem>

      <listitem>
        <para>Métodos no namespace <code>$</code> geralmente são
        métodos do tipo utilitário, e não funcionam em seleções; não são passados
        quaisquer argumentos automaticamente para eles, e seu valor de retorno
        variará.</para>
      </listitem>
    </itemizedlist>

    <para>Há alguns casos onde métodos de objeto e métodos do núcleo tem os
    mesmos nomes, tal como <code>$.each</code> e <code>$.fn.each</code>. Nesses
    casos, seja extremamente cuidadoso(a) ao ler a documentação para que você
    explore o método correto.</para>
  </section>

  <section>
    <title>Métodos Utilitários</title>

    <para>jQuery oferece diversos métodos utilitários no namespace
    <code>$</code>. Estes métodos são úteis para realizar tarefas rotineiras
    de programação. Abaixo estão exemplos de alguns dos métodos utilitários; para uma
    referência completa sobre métodos utilitários do jQuery, visite <link
    xlink:href="http://api.jquery.com/category/utilities/">http://api.jquery.com/category/utilities/</link>.</para>

    <variablelist>
      <varlistentry>
        <term>$.trim</term>

        <listitem>
          <para>Remove espaços em branco à esquerda e à direita.</para>

          <programlisting>$.trim('    muitos espaços em branco extras    ');
// returns 'muitos espaços em branco extras'</programlisting>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$.each</term>

        <listitem>
          <para>Itera sobre arrays e objetos.</para>

          <programlisting>$.each([ 'foo', 'bar', 'baz' ], function(idx, val) {
    console.log('elemento ' + idx + 'é ' + val);
});

$.each({ foo : 'bar', baz : 'bim' }, function(k, v) {
    console.log(k + ' : ' + v);
});</programlisting>

          <note>
            <para>Há também um método <code>$.fn.each</code>, que é usado
            para iterar sobre uma seleção de elementos.</para>
          </note>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$.inArray</term>

        <listitem>
          <para>Retorna o índice de um valor em um array, ou -1 se o valor não
          estiver no array.</para>

          <programlisting>var meuArray = [ 1, 2, 3, 5 ];

if ($.inArray(4, myArray) !== -1) {
    console.log('encontrei!');
}</programlisting>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$.extend</term>

        <listitem>
          <para>Muda as propriedades do primeiro objeto usando as
          propriedades dos objetos subsequentes.</para>

          <programlisting>var primeiroObjeto = { foo : 'bar', a : 'b' };
var segundoObjeto = { foo : 'baz' };

var novoObjeto = $.extend(primeiroObjeto, segundoObjeto);
console.log(primeiroObjeto.foo); // 'baz'
console.log(novoObjeto.foo);   // 'baz'</programlisting>

          <para>Se você não quer mudar nenhum dos objetos que passa para o
          <code>$.extend</code>, passe um objeto vazio como primeiro
          argumento.</para>

          <programlisting>var primeiroObjeto = { foo : 'bar', a : 'b' };
var segundoObjeto = { foo : 'baz' };

var novoObjeto = $.extend({}, primeiroObjeto, segundoObjeto);
console.log(primeiroObjeto.foo); // 'bar'
console.log(novoObjeto.foo);   // 'baz'</programlisting>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>$.proxy</term>

        <listitem>
          <para>Returna uma função que sempre será executada no escopo fornececido
          — isto é, seta o significado do <code>this</code> dentro da função
          passada ao segundo argumento.</para>

          <programlisting>var minhaFuncao = function() { console.log(this); };
var meuObjeto = { foo : 'bar' };

minhaFuncao(); // loga o objeto window

var minhaFuncaoComProxy = $.proxy(minhaFuncao, meuObjeto);
minhaFuncaoComProxy(); // loga o objeto meuObjeto</programlisting>

          <para>Se você tiver um objeto com métodos, pode passar o objeto
          e o nome do método para retornar uma função que sempre será
          executada no escopo do objeto.</para>

          <programlisting>var meuObjeto = {
    minhaFn : function() {
        console.log(this);
    }
};

$('#foo').click(meuObjeto.minhaFn); // loga o elemento DOM #foo
$('#foo').click($.proxy(meuObjeto, 'minhaFn')); // loga meuObjeto</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  
  <section>
    <title>Checking types</title>

    <para>As mentioned in the "JavaScript basics" section, jQuery offers
    a few basic utility methods for determining the type of a specific
    value.</para>
    
    <example>
      <title>Checking the type of an arbitrary value</title>

      <programlisting>var myValue = [1, 2, 3];

// Using JavaScript's typeof operator to test for primative types
typeof myValue == 'string'; // false
typeof myValue == 'number'; // false
typeof myValue == 'undefined'; // false
typeof myValue == 'boolean'; // false

// Using strict equality operator to check for null
myValue === null; // false

// Using jQuery's methods to check for non-primative types
jQuery.isFunction(myValue); // false
jQuery.isPlainObject(myValue); // false
jQuery.isArray(myValue); // true</programlisting>
    </example>
    
  </section>

  <section>
    <title>Data Methods</title>

    <para>As your work with jQuery progresses, you'll find that there's often
    data about an element that you want to store with the element. In plain
    JavaScript, you might do this by adding a property to the DOM element, but
    you'd have to deal with memory leaks in some browsers. jQuery offers a
    straightforward way to store data related to an element, and it manages
    the memory issues for you.</para>

    <example>
      <title>Storing and retrieving data related to an element</title>

      <programlisting>$('#myDiv').data('keyName', { foo : 'bar' });
$('#myDiv').data('keyName'); // { foo : 'bar' }</programlisting>
    </example>

    <para>You can store any kind of data on an element, and it's hard to
    overstate the importance of this when you get into complex application
    development. For the purposes of this class, we'll mostly use
    <code>$.fn.data</code> to store references to other elements.</para>

    <para>For example, we may want to establish a relationship between a list
    item and a div that's inside of it. We could establish this relationship
    every single time we interact with the list item, but a better solution
    would be to establish the relationship once, and then store a pointer to
    the div on the list item using <code>$.fn.data</code>:</para>

    <example>
      <title>Storing a relationship between elements using
      <code>$.fn.data</code></title>

      <programlisting>$('#myList li').each(function() {
    var $li = $(this), $div = $li.find('div.content');
    $li.data('contentDiv', $div);
});

// later, we don't have to find the div again;
// we can just read it from the list item's data
var $firstLi = $('#myList li:first');
$firstLi.data('contentDiv').html('new content');</programlisting>
    </example>

    <para>In addition to passing <code>$.fn.data</code> a single key-value
    pair to store data, you can also pass an object containing one or more
    pairs.</para>
  </section>

  <section>
    <title>Feature &amp; Browser Detection</title>

    <para>Although jQuery eliminates most JavaScript browser quirks, there are
    still occasions when your code needs to know about the browser
    environment.</para>

    <para>jQuery offers the <code>$.support</code> object, as well as the
    deprecated <code>$.browser</code> object, for this purpose. For complete
    documentation on these objects, visit <link
    xlink:href="http://api.jquery.com/jQuery.support/">http://api.jquery.com/jQuery.support/</link>
    and <link
    xlink:href="http://api.jquery.com/jQuery.browser/">http://api.jquery.com/jQuery.browser/</link>.</para>

    <para>The <code>$.support</code> object is dedicated to determining what
    features a browser supports; it is recommended as a more “future-proof”
    method of customizing your JavaScript for different browser
    environments.</para>

    <para>The <code>$.browser</code> object was deprecated in favor of the
    <code>$.support</code> object, but it will not be removed from jQuery
    anytime soon. It provides direct detection of the browser brand and
    version.</para>
  </section>

  <section>
    <title>Avoiding Conflicts with Other Libraries</title>

    <para>If you are using another JavaScript library that uses the
    <code>$</code> variable, you can run into conflicts with jQuery. In order
    to avoid these conflicts, you need to put jQuery in no-conflict mode
    immediately after it is loaded onto the page and before you attempt to use
    jQuery in your page.</para>

    <para>When you put jQuery into no-conflict mode, you have the option of
    assigning a variable name to replace <code>$</code>.</para>

    <example>
      <title>Putting jQuery into no-conflict mode</title>

      <programlisting>&lt;script src="prototype.js"&gt;&lt;/script&gt;
&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;var $j = jQuery.noConflict();&lt;/script&gt;</programlisting>
    </example>

    <para>You can continue to use the standard <code>$</code> by wrapping your
    code in a self-executing anonymous function; this is a standard pattern
    for plugin authoring, where the author cannot know whether another library
    will have taken over the <code>$</code>.</para>

    <example>
      <title>Using the $ inside a self-executing anonymous function</title>

      <programlisting>&lt;script src="prototype.js"&gt;&lt;/script&gt;
&lt;script src="jquery.js"&gt;&lt;/script&gt;
&lt;script&gt;
jQuery.noConflict();

(function($) {
   // your code here, using the $
})(jQuery);
&lt;/script&gt;</programlisting>
    </example>
  </section>
</chapter>
